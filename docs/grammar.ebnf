# Manta grammar (EBNF - draft)

; This EBNF is a starting point for the Manta language parser. It's intentionally concrete
; and maps to the language elements described in `docs/language_spec.md`.
;
; Note: This is a simplified grammar for the initial compiler front-end. It omits some
; expression precedence and all operator details for brevity; these should be expanded
; into a full expression grammar during implementation.

program       := { top_level_decl } ; file of declarations

top_level_decl := function_decl | type_decl | import_decl | const_decl

function_decl := 'fn' identifier '(' param_list? ')' return_type? block
param_list    := param (',' param)*
param         := identifier (type_spec)?
return_type   := type_spec

type_decl     := 'type' identifier ( 'enum' '{' enum_variant+ '}' | 'struct' '{' field_decl* '}' )
enum_variant  := identifier ( '(' type_spec ')' )? ; variants optionally carry a single type

field_decl    := identifier type_spec

const_decl    := 'const' identifier '=' expression
import_decl   := 'import' ( STRING | import_block )

import_block  := '(' STRING+ ')'
block         := '{' statement* '}'

statement     := let_stmt | decl_stmt | assign_stmt | try_stmt | expr_stmt | return_stmt | defer_stmt | match_stmt
let_stmt      := 'let' identifier (type_spec | (type_spec? '=' expression))
decl_stmt     := identifier ':=' expression
assign_stmt   := identifier '=' expression
try_stmt      := identifier? '.' identifier '(' identifier ')' ':=' try_expr
return_stmt   := 'return' expression?
defer_stmt    := 'defer' block
match_stmt    := 'match' expression '{' match_arm+ '}'
match_arm     := pattern block
pattern       := identifier? '.' identifier ( '(' identifier ')' )? | literal | identifier | '_'

expr_stmt     := expression

expression  := try_expr | binary_expr | unary_expr | primary_expr

try_expr    := 'try' expression ('catch' '(' identifier ')' block)?

binary_expr   := expression binary_op expression

binary_op     := '+'  | '-'  | '*'  | '/'  | '%'
               | '==' | '!=' | '<'  | '>'  | '<=' | '>='
               | '&&' | '||'
               | '&'  | '|'

unary_expr    := unary_op unary_expr | primary_expr

unary_op      := '-' | '!' | '&' | '*'

primary_expr  := literal
               | identifier
               | '(' expression ')'
               | call_expr

call_expr     := identifier '(' argument_list? ')'
argument_list := expression (',' expression)*
literal       := INTEGER | FLOAT | STRING | 'nil' | 'true' | 'false'

type_spec     := basic_type | pointer_type | array_type | slice_type | identifier
basic_type    := 'i8' | 'i16' | 'i32' | 'i64' | 'isize' | 'u8' | 'u16' | 'u32' | 'u64' | 'usize' | 'f32' | 'f64' | 'bool' | 'char' | 'str'
pointer_type  := '*' type_spec
array_type    := '[' INTEGER ']' type_spec
slice_type    := '[]' type_spec

identifier    := IDENT

; Terminals: IDENT, INTEGER, FLOAT, STRING, and punctuation are defined in the lexer/token list

; End of EBNF draft
