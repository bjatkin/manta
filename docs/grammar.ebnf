# Manta grammar (EBNF - draft)

; This EBNF is a starting point for the Manta language parser. It's intentionally concrete
; and maps to the language elements described in `docs/language_spec.md`.
;
; Note: This is a simplified grammar for the initial compiler front-end. It omits some
; expression precedence and all operator details for brevity; these should be expanded
; into a full expression grammar during implementation.

program       := { top_level_decl } ; file of declarations

top_level_decl := function_decl | type_decl | import_decl | const_decl

function_decl := 'fn' identifier '(' param_list? ')' return_type? block
param_list    := param (',' param)*
param         := identifier (type_spec)?
return_type   := type_spec

type_decl     := 'type' identifier ( 'enum' '{' enum_variant+ '}' | 'struct' '{' field_decl* '}' )
enum_variant  := identifier ( '(' type_spec ')' )? ; variants optionally carry a single type

field_decl    := identifier type_spec

const_decl    := 'const' identifier '=' expression
import_decl   := 'import' ( STRING | import_block )

import_block  := '(' STRING+ ')'
block         := '{' statement* '}'

statement     := let_stmt | expr_stmt | return_stmt | defer_stmt | match_stmt
let_stmt      := 'let' identifier (type_spec)? (':=' | '=') expression
return_stmt   := 'return' expression?
defer_stmt    := 'defer' block
match_stmt    := 'match' expression '{' match_arm+ '}'
match_arm     := pattern block

expr_stmt     := expression

expression    := assignment_expr
assignment_expr := try_expr (('=' | ':=') try_expr)? ; simplified assignment

try_expr      := 'try' primary_expr ('catch' '(' identifier ')' block)?

primary_expr  := literal
               | identifier
               | identifier '(' type_spec ')'  ; enum variant constructor / pattern
               | '(' expression ')'
               | call_expr

call_expr     := identifier '(' argument_list? ')'
argument_list := expression (',' expression)*

pattern       := identifier? '.' identifier ( '(' pattern_list? ')' )? | literal | identifier | '_'
pattern_list  := pattern (',' pattern)*

literal       := INTEGER | FLOAT | STRING | 'nil' | 'true' | 'false'

type_spec     := basic_type | pointer_type | array_type | slice_type | identifier
basic_type    := 'i8' | 'i16' | 'i32' | 'i64' | 'isize' | 'u8' | 'u16' | 'u32' | 'u64' | 'usize' | 'f32' | 'f64' | 'bool' | 'char' | 'string'
pointer_type  := '*' type_spec
array_type    := '[' INTEGER ']' type_spec
slice_type    := '[]' type_spec

identifier    := IDENT

; Terminals: IDENT, INTEGER, FLOAT, STRING, and punctuation are defined in the lexer/token list

; End of EBNF draft
